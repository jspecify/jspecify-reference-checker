import org.gradle.plugins.ide.eclipse.model.Output
import org.gradle.plugins.ide.eclipse.model.SourceFolder

plugins {
    id 'eclipse'
    id 'java'
    id 'maven-publish'

    id 'com.diffplug.spotless' version '6.14.0'
    id 'io.github.gradle-nexus.publish-plugin' version '1.3.0'
    id 'net.ltgt.errorprone' version '3.0.1'
}

// Nexus Publish plugin requires a group/version at the root project.
group = 'org.jspecify.reference'
version = '0.0.0-SNAPSHOT'

repositories {
    mavenLocal()
    maven {
        // Nexus snapshot repository
        url = "https://s01.oss.sonatype.org/content/repositories/snapshots/"
    }
    mavenCentral()
}

nexusPublishing {
    repositories {
        sonatype {
            // For users registered in Sonatype after 24 Feb 2021
            nexusUrl = uri("https://s01.oss.sonatype.org/service/local/")
            snapshotRepositoryUrl = uri("https://s01.oss.sonatype.org/content/repositories/snapshots/")
        }
    }
}

ext {
    checkerFramework = gradle.includedBuild("checker-framework")

    // null if not included with `--include-build path/to/jspecify`
    jspecify = gradle.includedBuilds.find { it.name == 'jspecify' }
}

configurations {
    errorproneJavac
    conformanceTestSuite {
        // When including a local JSpecify build, depend on the local test suite.
        // See https://docs.gradle.org/current/userguide/cross_project_publications.html#sec:variant-aware-sharing.
        if (jspecify != null) {
            attributes {
                attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, 'conformance-tests'))
            }
        }
    }
}

java {
    sourceCompatibility = 1.9
}

dependencies {
    implementation libs.checkerFramework.checker
    implementation libs.checkerFramework.checker.qual
    implementation libs.checkerFramework.framework
    implementation libs.checkerFramework.javacutil

    implementation libs.jspecify

    testImplementation libs.checkerFramework.framework.test
    testImplementation libs.guava
    testImplementation libs.junit
    testImplementation libs.jspecify.conformanceTestFramework
    testRuntimeOnly libs.jsr305 // jsr305 annotations are in some of the samples

    conformanceTestSuite libs.jspecify.conformanceTests

    errorproneJavac libs.errorProne.javac
    errorprone libs.errorProne.core
}

// Assemble checker-framework when assembling the reference checker.
assemble.dependsOn(checkerFramework.task(":assemble"))

// If built with `--include-build path/to/jspecify` then
// assemble jspecify when assembling the reference checker.
if (jspecify != null) {
    assemble.dependsOn(jspecify.task(':assemble'))
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs.add("-Xlint:all")
    // ErrorProne makes suppressing these easier
    options.compilerArgs.add("-Xlint:-fallthrough")

    options.errorprone.disable("BadImport")

    options.compilerArgs.addAll(
            [
                "api",
                "code",
                "comp",
                "file",
                "main",
                "model",
                "parser",
                "processing",
                "resources",
                "tree",
                "util",
            ]
            .collect { "--add-exports=jdk.compiler/com.sun.tools.javac.$it=ALL-UNNAMED" })
}

tasks.withType(Test).configureEach {
    if (!JavaVersion.current().java9Compatible) {
        jvmArgs "-Xbootclasspath/p:${configurations.errorproneJavac.asPath}"
    }

    // Required because checker-framework uses APIs from these modules.
    jvmArgs(
            [
                "code",
                "comp",
                "main",
                "processing",
                "tree",
                "util",
            ]
            .collect { "--add-opens=jdk.compiler/com.sun.tools.javac.$it=ALL-UNNAMED" })

    testLogging {
        showStackTraces = false
        showStandardStreams = true
        events "failed"
        exceptionFormat "full"
    }
}

test {
    include '**/NullSpecTest$Minimal.class'

    inputs.files("${rootDir}/tests/minimal")
}

tasks.register('jspecifySamplesTest', Test) {
    description = 'Run the checker against the JSpecify samples.'
    group = 'verification'
    shouldRunAfter test
    include '**/NullSpecTest$Lenient.class'
    include '**/NullSpecTest$Strict.class'

    inputs.files(unzipConformanceTestSuite)
}

tasks.register('unzipConformanceTestSuite', Copy) {
    dependsOn configurations.conformanceTestSuite
    from zipTree(configurations.conformanceTestSuite.singleFile)
    into layout.buildDirectory.dir("conformanceTests")
}

tasks.register('conformanceTests', Test) {
    group = 'verification'
    include '**/ConformanceTest.class'
    shouldRunAfter test

    // Conformance tests
    inputs.files(unzipConformanceTestSuite)
    inputs.files("tests/ConformanceTest-report.txt")
    doFirst {
        systemProperties([
            "JSpecifyConformanceTest.inputs": "${unzipConformanceTestSuite.destinationDir}/assertions/org/jspecify/conformance/tests",
            "JSpecifyConformanceTest.report": "tests/ConformanceTest-report.txt",
            "JSpecifyConformanceTest.deps"  : fileTree("${unzipConformanceTestSuite.destinationDir}/deps").join(":")
        ])
    }

    // Conformance tests run on the samples directory
    inputs.files("tests/ConformanceTestOnSamples-report.txt")
    doFirst {
        systemProperties([
            "JSpecifyConformanceTest.samples.inputs": "${unzipConformanceTestSuite.destinationDir}/samples",
            "JSpecifyConformanceTest.samples.report": "tests/ConformanceTestOnSamples-report.txt"
        ])
    }
}

tasks.named('check').configure {
    dependsOn('conformanceTests')
}

clean.doFirst {
    delete "${rootDir}/tests/build/"
}

tasks.register('demoTest', Exec)  {
    group = 'verification'
    shouldRunAfter 'conformanceTests'
    dependsOn assemble
    inputs.files('demo', 'SimpleSample.java')
    executable '/bin/sh'
    args 'demo', 'SimpleSample.java'
    ignoreExitValue = true
    errorOutput = new ByteArrayOutputStream()
    doLast {
        if (!errorOutput.toString().contains("SimpleSample.java:7: error:")) {
            throw new AssertionError("`./demo SimpleSample.java` did not run correctly. Error output:\n$errorOutput")
        }
    }
}

/*
 Spotless validates its formatters' dependencies eagerly, on project configuration.
 google-java-format depends on checker-qual, which is built by a subproject.
 On a clean build, the checker-qual JAR file doesn't exist yet, so Spotless throws an error.
 The file doesn't have to be correct; it just has to be a JAR file.
 So here, before the spotless block,  we create a meaningless JAR file at that location if it doesn't already exist.
 See https://github.com/jspecify/jspecify-reference-checker/issues/81
 */

def cfQualJar =
        checkerFramework.projectDir.toPath()
        .resolve("checker-qual/build/libs/checker-qual-${libs.versions.checkerFramework.get()}.jar")

if (!cfQualJar.toFile().exists()) {
    mkdir(cfQualJar.parent)
    exec {
        executable 'jar'
        args = [
            'cf',
            cfQualJar,
            buildFile.path // Use this build script file!
        ]
    }
}

spotless {
    java {
        googleJavaFormat()
        formatAnnotations()
    }
    groovyGradle {
        target '**/*.gradle'
        greclipse()
        indentWithSpaces(4)
        trimTrailingWhitespace()
    }
}

// Use `./gradlew eclipseClasspath` to create Eclipse/VSCode configurations
eclipse.classpath {
    defaultOutputDir = file("build/default")
    file.whenMerged { cp ->
        cp.entries.forEach { cpe ->
            if (cpe instanceof SourceFolder) {
                cpe.output = cpe.output.replace "bin/", "build/classes/java/"
            }
            if (cpe instanceof Output) {
                cpe.path = cpe.path.replace "bin/", "build/"
            }
        }
    }
}
