import org.gradle.plugins.ide.eclipse.model.Output
import org.gradle.plugins.ide.eclipse.model.SourceFolder

plugins {
    id 'java'
    id 'com.diffplug.spotless' version '6.14.0'
    id 'eclipse'
    // https://github.com/tbroyer/gradle-errorprone-plugin
    id 'net.ltgt.errorprone' version '3.0.1'
}

repositories {
    mavenCentral()
}

configurations {
    errorproneJavac
    testAssertions {
        attributes {
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
        }
    }
    testDeps
}

ext {
    checkerFramework = gradle.includedBuild("checker-framework")
    jspecify = gradle.includedBuild("jspecify")
}

java {
    sourceCompatibility = 1.9
}

dependencies {
    implementation libs.checkerFramework.checker
    implementation libs.checkerFramework.checker.qual
    implementation libs.checkerFramework.framework
    implementation libs.checkerFramework.javacutil

    implementation libs.jspecify

    testImplementation libs.checkerFramework.framework.test
    testImplementation libs.guava
    testImplementation libs.junit
    testImplementation libs.jspecify.conformanceTest.framework
    testRuntimeOnly libs.jsr305 // jsr305 annotations are in some of the samples

    testAssertions("org.jspecify.conformance:conformance-tests:0.0.0-SNAPSHOT") {
        capabilities {
            requireCapability "org.jspecify.conformance:conformance-tests-assertions"
        }
    }

    testDeps("org.jspecify.conformance:conformance-tests:0.0.0-SNAPSHOT") {
        capabilities {
            requireCapability "org.jspecify.conformance:conformance-tests-deps"
        }
    }

    errorproneJavac libs.errorProne.javac
    errorprone libs.errorProne.core
}

// Assemble checker-framework when assembling the reference checker.
assemble.dependsOn(checkerFramework.task(":assemble"))
assemble.dependsOn(jspecify.task(":assemble"))

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs.add("-Xlint:all")
    // ErrorProne makes suppressing these easier
    options.compilerArgs.add("-Xlint:-fallthrough")

    options.errorprone.disable("BadImport")

    options.compilerArgs.addAll(
            [
                "api",
                "code",
                "comp",
                "file",
                "main",
                "model",
                "parser",
                "processing",
                "resources",
                "tree",
                "util",
            ]
            .collect { "--add-exports=jdk.compiler/com.sun.tools.javac.$it=ALL-UNNAMED" })
}

tasks.withType(Test).configureEach {
    if (!JavaVersion.current().java9Compatible) {
        jvmArgs "-Xbootclasspath/p:${configurations.errorproneJavac.asPath}"
    }

    // Required because checker-framework uses APIs from these modules.
    jvmArgs(
            [
                "code",
                "comp",
                "main",
                "processing",
                "tree",
                "util",
            ]
            .collect { "--add-opens=jdk.compiler/com.sun.tools.javac.$it=ALL-UNNAMED" })

    testLogging {
        showStackTraces = false
        showStandardStreams = true
        events "failed"
        exceptionFormat "full"
    }
}

test {
    include '**/NullSpecTest$Minimal.class'

    inputs.files("${rootDir}/tests/minimal")
}

tasks.register('jspecifySamplesTest', Test) {
    description = 'Run the checker against the JSpecify samples.'
    group = 'verification'
    include '**/NullSpecTest$Lenient.class'
    include '**/NullSpecTest$Strict.class'

    inputs.files("${jspecify.projectDir}/samples")
}

TaskProvider<Test> conformanceTest(String name, String testDirectory, String reportFile) {
    check.dependsOn(name)
    return tasks.register(name, Test) {
        group = 'verification'
        include '**/ConformanceTest.class'
        inputs.dir(testDirectory)
        inputs.files(reportFile)
        systemProperty("JSpecifyConformanceTest.sourceDirectory", testDirectory)
        systemProperty("JSpecifyConformanceTest.report", reportFile)
    }
}

tasks.register('unzipConformanceTestAssertions', Copy) {
    dependsOn configurations.testAssertions
    from zipTree(configurations.testAssertions.singleFile)
    exclude 'META-INF/'
    into "${buildDir}/conformanceTests"
}

conformanceTest('conformanceTest', "${buildDir}/conformanceTests/org/jspecify/conformance/tests", 'tests/ConformanceTest-report.txt').configure {
    dependsOn 'unzipConformanceTestAssertions', configurations.testDeps
    inputs.files(configurations.testDeps)
    systemProperty("JSpecifyConformanceTest.testDeps", configurations.testDeps.join(":"))
}

conformanceTest('conformanceTestOnSamples', "${jspecify.projectDir}/samples", 'tests/ConformanceTestOnSamples-report.txt')

clean.doFirst {
    delete "${rootDir}/tests/build/"
}

/*
 Spotless validates its formatters' dependencies eagerly, on project configuration.
 google-java-format depends on checker-qual, which is built by a subproject.
 On a clean build, the checker-qual JAR file doesn't exist yet, so Spotless throws an error.
 The file doesn't have to be correct; it just has to be a JAR file.
 So here, before the spotless block,  we create a meaningless JAR file at that location if it doesn't already exist.
 See https://github.com/jspecify/jspecify-reference-checker/issues/81
 */

def cfQualJar =
        checkerFramework.projectDir.toPath()
        .resolve("checker-qual/build/libs/checker-qual-${libs.versions.checkerFramework.get()}.jar")

if (!cfQualJar.toFile().exists()) {
    mkdir(cfQualJar.parent)
    exec {
        executable 'jar'
        args = [
            'cf',
            cfQualJar,
            buildFile.path // Use this build script file!
        ]
    }
}

spotless {
    java {
        googleJavaFormat()
        formatAnnotations()
    }
    groovyGradle {
        target '**/*.gradle'
        greclipse()
        indentWithSpaces(4)
        trimTrailingWhitespace()
    }
}

// Use `./gradlew eclipseClasspath` to create Eclipse/VSCode configurations
eclipse.classpath {
    defaultOutputDir = file("build/default")
    file.whenMerged { cp ->
        cp.entries.forEach { cpe ->
            if (cpe instanceof SourceFolder) {
                cpe.output = cpe.output.replace "bin/", "build/classes/java/"
            }
            if (cpe instanceof Output) {
                cpe.path = cpe.path.replace "bin/", "build/"
            }
        }
    }
}
