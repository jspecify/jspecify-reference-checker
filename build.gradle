import org.gradle.plugins.ide.eclipse.model.Output
import org.gradle.plugins.ide.eclipse.model.SourceFolder

plugins {
    id 'eclipse'
    id 'java'
    id 'maven-publish'

    id 'com.diffplug.spotless' version '6.25.0'
    id 'io.github.gradle-nexus.publish-plugin' version '1.3.0'
    id 'net.ltgt.errorprone' version '3.0.1'
}

// Nexus Publish plugin requires a group/version at the root project.
group = 'org.jspecify.reference'
version = '0.0.0-SNAPSHOT'

sourceSets {
    main {
        resources {
            // Minimized jspecify/jdk
            srcDirs += [
                "${buildDir}/generated/resources"
            ]
        }
    }
}

repositories {
    mavenLocal()
    maven {
        // Nexus snapshot repository
        url = "https://s01.oss.sonatype.org/content/repositories/snapshots/"
    }
    mavenCentral()
}

nexusPublishing {
    repositories {
        sonatype {
            // For users registered in Sonatype after 24 Feb 2021
            nexusUrl = uri("https://s01.oss.sonatype.org/service/local/")
            snapshotRepositoryUrl = uri("https://s01.oss.sonatype.org/content/repositories/snapshots/")
        }
    }
}

ext {
    // null if not included with `--include-build path/to/checker-framework`
    checkerFramework = gradle.includedBuilds.find { it.name == 'checker-framework' }

    // null if not included with `--include-build path/to/jspecify`
    jspecify = gradle.includedBuilds.find { it.name == 'jspecify' }

    // Location of the jspecify/jdk clone, relative to this directory
    jspecifyJdkHome = '../jdk'
}

configurations {
    errorproneJavac
    conformanceTestSuite {
        // When including a local JSpecify build, depend on the local test suite.
        // See https://docs.gradle.org/current/userguide/cross_project_publications.html#sec:variant-aware-sharing.
        if (jspecify != null) {
            attributes {
                attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, 'conformance-tests'))
            }
        }
    }
}

java {
    sourceCompatibility = 1.9
}

dependencies {
    implementation libs.checkerFramework.checker
    implementation libs.checkerFramework.checker.qual
    // Eventually, we would want to only depend on `framework` and
    // `javacutil` artifacts instead of the entire `checker`.
    // implementation libs.checkerFramework.framework
    // implementation libs.checkerFramework.javacutil

    implementation libs.jspecify

    testImplementation libs.checkerFramework.framework.test
    testImplementation libs.guava
    testImplementation libs.junit
    testImplementation libs.jspecify.conformanceTestFramework
    testRuntimeOnly libs.jsr305 // jsr305 annotations are in some of the samples

    conformanceTestSuite libs.jspecify.conformanceTests

    errorproneJavac libs.errorProne.javac
    errorprone libs.errorProne.core
}

// If built with `--include-build path/to/checker-framework` then
// assemble checker-framework when assembling the reference checker.
if (checkerFramework != null) {
    assemble.dependsOn(checkerFramework.task(":checker:assembleForJavac"))
}

// If built with `--include-build path/to/jspecify` then
// assemble jspecify when assembling the reference checker.
if (jspecify != null) {
    assemble.dependsOn(jspecify.task(':assemble'))
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs.add("-Xlint:all")
    // ErrorProne makes suppressing these easier
    options.compilerArgs.add("-Xlint:-fallthrough")

    options.errorprone.disable("BadImport")

    options.compilerArgs.addAll(
            [
                "api",
                "code",
                "comp",
                "file",
                "main",
                "model",
                "parser",
                "processing",
                "resources",
                "tree",
                "util",
            ]
            .collect { "--add-exports=jdk.compiler/com.sun.tools.javac.$it=ALL-UNNAMED" })
}

tasks.register('includeJSpecifyJDK')  {
    group = 'Build'
    shouldRunAfter 'compileJava'

    def srcDir = "${jspecifyJdkHome}/src"
    // This directory needs to be stored at the top-level of the resulting .jar file.
    // org.checkerframework.framework.stub.AnnotationFileElementTypes will then load
    // the JDK classes from here instead of from checker.jar.
    def dstDir = "${buildDir}/generated/resources/annotated-jdk/src/"

    inputs.dir file(srcDir)
    outputs.dir file(dstDir)

    doLast {
        FileTree srcTree = fileTree(dir: srcDir)
        NavigableSet<String> specFiles = new TreeSet<>();
        srcTree.visit { FileVisitDetails fvd ->
            if (!fvd.file.isDirectory() && fvd.file.name.matches('.*\\.java')) {
                fvd.getFile().readLines().any { line ->
                    if (line.contains('org.jspecify')) {
                        specFiles.add(fvd.file.absolutePath)
                        return true;
                    }
                }
            }
        }
        String absoluteSrcDir = file(srcDir).absolutePath
        int srcPrefixSize = absoluteSrcDir.size()
        copy {
            from(srcDir)
            into(dstDir)
            for (String specFile : specFiles) {
                include specFile.substring(srcPrefixSize)
            }
        }
        javaexec {
            classpath = sourceSets.main.runtimeClasspath
            standardOutput = System.out
            errorOutput = System.err

            mainClass = 'org.checkerframework.framework.stub.JavaStubifier'
            args dstDir
        }
    }
}

processResources.dependsOn(includeJSpecifyJDK)

tasks.withType(Test).configureEach {
    if (!JavaVersion.current().java9Compatible) {
        jvmArgs "-Xbootclasspath/p:${configurations.errorproneJavac.asPath}"
    }

    // Required because checker-framework uses APIs from these modules.
    jvmArgs(
            [
                "code",
                "comp",
                "main",
                "processing",
                "tree",
                "util",
            ]
            .collect { "--add-opens=jdk.compiler/com.sun.tools.javac.$it=ALL-UNNAMED" })

    testLogging {
        showStackTraces = false
        showStandardStreams = true
        events "failed"
        exceptionFormat "full"
    }
}

test {
    include '**/NullSpecTest$Minimal.class'
    inputs.files("${rootDir}/tests/minimal")

    include '**/NullSpecTest$Regression.class'
    inputs.files("${rootDir}/tests/regression")
}

tasks.register('jspecifySamplesTest', Test) {
    description = 'Run the checker against the JSpecify samples.'
    group = 'verification'
    shouldRunAfter test
    include '**/NullSpecTest$Lenient.class'
    include '**/NullSpecTest$Strict.class'

    inputs.files(unzipConformanceTestSuite)
}

tasks.register('unzipConformanceTestSuite', Copy) {
    dependsOn configurations.conformanceTestSuite
    from zipTree(configurations.conformanceTestSuite.singleFile)
    into layout.buildDirectory.dir("conformanceTests")
}

tasks.register('conformanceTests', Test) {
    group = 'verification'
    include '**/ConformanceTest.class'
    shouldRunAfter test

    // Conformance tests
    inputs.files(unzipConformanceTestSuite)
    inputs.files("tests/ConformanceTest-report.txt")
    doFirst {
        systemProperties([
            "JSpecifyConformanceTest.inputs": "${unzipConformanceTestSuite.destinationDir}/assertions/org/jspecify/conformance/tests",
            "JSpecifyConformanceTest.report": "tests/ConformanceTest-report.txt",
            "JSpecifyConformanceTest.deps"  : fileTree("${unzipConformanceTestSuite.destinationDir}/deps").join(":")
        ])
    }

    // Conformance tests run on the samples directory
    inputs.files("tests/ConformanceTestOnSamples-report.txt")
    doFirst {
        systemProperties([
            "JSpecifyConformanceTest.samples.inputs": "${unzipConformanceTestSuite.destinationDir}/samples",
            "JSpecifyConformanceTest.samples.report": "tests/ConformanceTestOnSamples-report.txt"
        ])
    }
}

tasks.named('check').configure {
    dependsOn('conformanceTests')
}

clean.doFirst {
    delete "${rootDir}/tests/build/"
}

tasks.register('demoTest', Exec)  {
    group = 'verification'
    shouldRunAfter 'conformanceTests'
    dependsOn assemble
    inputs.files('demo', 'SimpleSample.java')
    executable '/bin/sh'
    args 'demo', 'SimpleSample.java'
    ignoreExitValue = true
    errorOutput = new ByteArrayOutputStream()
    doLast {
        if (!errorOutput.toString().contains("SimpleSample.java:7: error:")) {
            throw new AssertionError("`./demo SimpleSample.java` did not run correctly. Error output:\n$errorOutput")
        }
    }
}

/*
 Spotless validates its formatters' dependencies eagerly, on project configuration.
 google-java-format depends on checker-qual, which is built by a subproject.
 On a clean build, the checker-qual JAR file doesn't exist yet, so Spotless throws an error.
 The file doesn't have to be correct; it just has to be a JAR file.
 So here, before the spotless block,  we create a meaningless JAR file at that location if it doesn't already exist.
 See https://github.com/jspecify/jspecify-reference-checker/issues/81
 */

if (checkerFramework != null) {
    def cfQualJar =
            checkerFramework.projectDir.toPath()
            .resolve("checker-qual/build/libs/checker-qual-${libs.versions.checkerFramework.get()}.jar")

    if (!cfQualJar.toFile().exists()) {
        mkdir(cfQualJar.parent)
        exec {
            executable 'jar'
            args = [
                'cf',
                cfQualJar,
                buildFile.path // Use this build script file!
            ]
        }
    }
}

spotless {
    java {
        target '**/*.java'
        googleJavaFormat()
        formatAnnotations()
    }
    groovyGradle {
        target '**/*.gradle'
        greclipse()
        indentWithSpaces(4)
        trimTrailingWhitespace()
    }
}

// Use `./gradlew eclipseClasspath` to create Eclipse/VSCode configurations
eclipse.classpath {
    defaultOutputDir = file("build/default")
    file.whenMerged { cp ->
        cp.entries.forEach { cpe ->
            if (cpe instanceof SourceFolder) {
                cpe.output = cpe.output.replace "bin/", "build/classes/java/"
            }
            if (cpe instanceof Output) {
                cpe.path = cpe.path.replace "bin/", "build/"
            }
        }
    }
}

publishing {
    publications {
        jspecifyReferenceChecker(MavenPublication) {
            pom {
                groupId = 'org.jspecify.reference'
                artifactId = 'checker'
                version = project.version
                name = 'JSpecify Reference Checker'
                description = 'The JSpecify Reference Checker'
                url = 'http://jspecify.org/'
                from components.java
                licenses {
                    license {
                        name = 'The Apache License, Version 2.0'
                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }
                scm {
                    connection = 'scm:git:git@github.com:jspecify/jspecify-reference-checker.git'
                    developerConnection = 'scm:git:git@github.com:jspecify/jspecify-reference-checker.git'
                    url = 'https://github.com/jspecify/jspecify-reference-checker'
                }
                developers {
                    developer {
                        id = 'cpovirk'
                        name = 'Chris Povirk'
                        email = 'cpovirk@google.com'
                    }
                    developer {
                        id = 'netdpb'
                        name = 'David P. Baker'
                        email = 'dpb@google.com'
                    }
                    developer {
                        id = 'wmdietl'
                        name = 'Werner M. Dietl'
                        email = 'wdietl@gmail.com'
                    }
                }
            }
        }
    }
}
