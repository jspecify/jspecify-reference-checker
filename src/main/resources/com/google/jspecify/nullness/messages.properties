atomicreference.must.include.null=expected a @Nullable type argument or else an initial-value constructor argument. The no-arg AtomicReference constructor sets the initial value to null, which is not compatible with %s.
dereference=possible null dereference on type %s
enum.constant.annotated=illegal location for annotation: enum constants are always non-null
local.variable.annotated=illegal location for annotation %s: local variables have their nullness automatically inferred (except for their type arguments, as in `List<@Nullable String>`)
outer.annotated=illegal location for annotation: outer types are always non-null. To annotate the inner type, write `Foo.@Nullable Bar` instead of `@Nullable Foo.Bar`.
primitive.annotated=illegal location for annotation %s: primitives are always non-null. To annotate an array of primitives as nullable, write `int @Nullable[]` instead of `@Nullable int[]`.
threadlocal.must.include.null=expected a @Nullable type argument or else an override of initialValue(). Without an override of initialValue(), ThreadLocal.get() may return null, which is not compatible with %s.
type.parameter.annotated=illegal location for annotation %s: type parameter declarations do not have a nullness. To declare that a type parameter may be instantiated with nullable types, write `T extends @Nullable Object` instead of `@Nullable T`.
wildcard.annotated=illegal location for annotation %s: wildcard declarations do not have a nullness. To declare that a wildcard may match nullable types, write `? extends @Nullable Object` instead of `@Nullable ?`. Or, in null-aware code, simply write `?`.
